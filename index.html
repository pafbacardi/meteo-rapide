<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Météo rapide !</title>
    <style>
        /* Variables CSS par défaut (pour le thème initial/fallback) */
        body {
            --main-bg: #e0f7fa;
            --main-text: #333;
            --header-text: #4A148C;
            --section-text: #6A1B9A;
            --card-bg: #F3E5F5;
            --button-bg: #8E24AA;
            --button-text: white;
            --input-border: #B39DDB;
            --select-bg: #f3e5f5;
            --select-text: #4A148C;
            --city-option-bg: #90CAF9;
            --temp-color: #D84315;
            --precipitation-color: #00838f;
            --feels-like-color: #8D6E63;
            --input-section-bg: #EDE7F6;

            font-family: 'Comic Sans MS', cursive, sans-serif;
            text-align: center;
            margin: 10px; /* Marges réduites pour mobile */
            overflow-x: hidden; /* Empêche le défilement horizontal */

            background-color: var(--main-bg);
            color: var(--main-text);
            transition: background-color 0.8s ease, color 0.8s ease; /* Transition douce */
        }

        /* Application des variables aux éléments */
        h1 { color: var(--header-text); }
        #current-location-display { color: var(--header-text); }
        /* Style des titres de section mis à jour */
        .section-title {
            color: #2196F3; /* Bleu clair comme dans l'image */
            border-bottom: 2px solid #2196F3; /* Bordure bleue */
            padding-bottom: 5px; /* Espace sous la bordure */
            margin-top: 30px; /* Espace au-dessus de chaque section */
            margin-bottom: 15px; /* Espace sous le titre */
            font-size: 1.8em; /* Taille de police ajustée */
            font-weight: bold;
            /* text-align: center; -> Déplacé vers .toggle-title-text */
        }
        .weather-card { background-color: var(--card-bg); }
        .day-card { background-color: var(--card-bg); }
        .weather-button { background-color: var(--button-bg); color: var(--button-text); }
        /* Le bouton "Retour Charvieu" garde sa couleur spécifique */
        #btn-back-to-charvieu { background-color: #FFC107; color: #333; }
        .location-input-section { background-color: var(--input-section-bg); }
        .location-input-section input[type="text"] { border-color: var(--input-border); }
        .location-input-section button { background-color: var(--button-bg); color: var(--button-text); }
        select { background-color: var(--select-bg); color: var(--select-text); border-color: var(--input-border); }
        #city-selection-results { background-color: var(--card-bg); border-color: var(--input-border); }
        .city-option-button { background-color: var(--city-option-bg); color: var(--button-text); }
        .error-message { color: #e53935; } /* La couleur d'erreur reste rouge */
        .temp { color: var(--temp-color); }
        .temp-range { color: var(--temp-color); }
        .precipitation { color: var(--precipitation-color); }
        .feels-like { color: var(--feels-like-color); }


        /* Thèmes de couleurs spécifiques */
        .theme-sunny {
            --main-bg: #ffe082; /* Jaune doux */
            --main-text: #333;
            --header-text: #D84315; /* Orange plus vif */
            --section-text: #FF6F00; /* Orange */
            --card-bg: #fff9c4; /* Jaune très clair */
            --button-bg: #FFB300; /* Jaune orange */
            --button-text: #333;
            --input-border: #FFD54F;
            --select-bg: #fff9c4;
            --select-text: #333;
            --city-option-bg: #FFECB3;
            --temp-color: #E65100;
            --precipitation-color: #2196F3; /* Bleu pour la pluie sur fond ensoleillé */
            --feels-like-color: #BF360C;
            --input-section-bg: #FFF8E1;
        }

        .theme-cloudy {
            --main-bg: #cfd8dc; /* Gris bleuâtre doux */
            --main-text: #333;
            --header-text: #455A64; /* Gris foncé */
            --section-text: #607D8B; /* Gris */
            --card-bg: #eceff1; /* Gris très clair */
            --button-bg: #78909C; /* Gris bleu */
            --button-text: white;
            --input-border: #90A4AE;
            --select-bg: #eceff1;
            --select-text: #333;
            --city-option-bg: #B0BEC5;
            --temp-color: #BF360C;
            --precipitation-color: #00838f;
            --feels-like-color: #546E7A;
            --input-section-bg: #CFD8DC;
        }

        .theme-rainy {
            --main-bg: #a7c0d8; /* Bleu gris de pluie */
            --main-text: #333;
            --header-text: #1A237E; /* Bleu très foncé */
            --section-text: #283593; /* Bleu foncé */
            --card-bg: #e3f2fd; /* Bleu très très clair */
            --button-bg: #42A5F5; /* Bleu */
            --button-text: white;
            --input-border: #64B5F6;
            --select-bg: #e3f2fd;
            --select-text: #333;
            --city-option-bg: #90CAF9;
            --temp-color: #0D47A1;
            --precipitation-color: #004D40; /* Bleu-vert foncé */
            --feels-like-color: #3F51B5;
            --input-section-bg: #BBDEFB;
        }

        .theme-snowy {
            --main-bg: #e0f2f7; /* Blanc bleuâtre de neige */
            --main-text: #333;
            --header-text: #263238; /* Gris très foncé */
            --section-text: #455A64; /* Gris foncé */
            --card-bg: #f5f5f5; /* Presque blanc */
            --button-bg: #64B5F6; /* Bleu clair */
            --button-text: white;
            --input-border: #90CAF9;
            --select-bg: #f5f5f5;
            --select-text: #333;
            --city-option-bg: #BBDEFB;
            --temp-color: #1976D2;
            --precipitation-color: #0D47A1;
            --feels-like-color: #42A5F5;
            --input-section-bg: #E1F5FE;
        }

        .theme-thunderstorm {
            --main-bg: #8d6e63; /* Marron foncé pour l'orage */
            --main-text: #eee; /* Texte clair */
            --header-text: #FFCC80; /* Orange clair */
            --section-text: #FFAB40; /* Orange */
            --card-bg: #4e342e; /* Marron très foncé */
            --button-bg: #FF7043; /* Orange vif */
            --button-text: white;
            --input-border: #FF8A65;
            --select-bg: #4e342e;
            --select-text: #eee;
            --city-option-bg: #BF360C;
            --temp-color: #FFEB3B; /* Jaune vif */
            --precipitation-color: #BDBDBD; /* Gris */
            --feels-like-color: #FFAB40;
            --input-section-bg: #5D4037;
        }

        .theme-mist {
            --main-bg: #b0bec5; /* Gris brume */
            --main-text: #333;
            --header-text: #546E7A; /* Gris bleu foncé */
            --section-text: #78909C; /* Gris bleu */
            --card-bg: #cfd8dc; /* Gris bleuâtre doux */
            --button-bg: #90A4AE; /* Gris */
            --button-text: white;
            --input-border: #B0BEC5;
            --select-bg: #cfd8dc;
            --select-text: #333;
            --city-option-bg: #DCE7EB;
            --temp-color: #607D8B;
            --precipitation-color: #455A64;
            --feels-like-color: #78909C;
            --input-section-bg: #B0BEC5;
        }

        .theme-night {
            --main-bg: #263238; /* Bleu très foncé/presque noir */
            --main-text: #e0f2f7; /* Texte très clair */
            --header-text: #BBDEFB; /* Bleu clair */
            --section-text: #90CAF9; /* Bleu moyen */
            --card-bg: #37474F; /* Gris foncé */
            --button-bg: #42A5F5; /* Bleu */
            --button-text: white;
            --input-border: #64B5F6;
            --select-bg: #37474F;
            --select-text: #e0f2f7;
            --city-option-bg: #5C6BC0;
            --temp-color: #FFD54F; /* Jaune clair */
            --precipitation-color: #BBDEFB;
            --feels-like-color: #90CAF9;
            --input-section-bg: #455A64;
        }

        /* Nouvelle section pour l'en-tête principal */
        .main-header-section {
            display: flex;
            flex-direction: column; /* Par défaut, les éléments s'empilent sur mobile */
            align-items: center;
            justify-content: center;
            gap: 10px; /* Espacement entre les blocs */
            margin-bottom: 20px;
            padding: 10px;
            background-color: #ffffff;
            border-radius: 15px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .header-content-left {
            display: flex;
            flex-direction: column;
            align-items: center; /* Centré sur mobile */
            text-align: center; /* Centré sur mobile */
            flex-grow: 1; /* Prend l'espace disponible sur desktop */
        }
        h1 {
            font-size: 1.8em; /* Plus petit pour mobile */
            margin-bottom: 5px; /* Moins d'espace */
        }
        #current-location-display {
            font-size: 1.5em; /* Plus petit pour mobile */
            font-weight: bold;
            margin-bottom: 10px;
        }

        .button-container {
            display: flex;
            flex-direction: column; /* Boutons empilés par défaut sur mobile */
            gap: 10px; /* Espacement entre les boutons */
            margin-bottom: 10px;
        }
        
        /* Styles pour la carte */
        #map-container {
            width: 150px; /* Largeur fixe pour la carte sur mobile */
            height: 150px; /* Hauteur fixe pour la carte sur mobile */
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin-top: 10px; /* Espacement au-dessus de la carte sur mobile */
        }
        #map-iframe {
            width: 100%;
            height: 100%;
            border: none;
        }

        .container {
            background-color: #ffffff;
            border-radius: 15px;
            padding: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            max-width: 100%;
            margin: 10px auto;
        }
        
        /* Styles spécifiques pour le layout 4x6 (hourly) */
        .hourly-forecast {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 5px;
            justify-content: center;
            padding: 5px;
            box-sizing: border-box;
        }

        .weather-card {
            border-radius: 8px;
            padding: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            text-align: center;
            font-size: 0.8em;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 80px;
            box-sizing: border-box;
            position: relative; /* Pour positionner l'icône d'alerte */
        }
        /* Style pour les emojis météo */
        .weather-emoji {
            font-size: 2.5em; /* Grande taille pour les emojis */
            line-height: 1; /* Assure que l'emoji ne prend pas trop de hauteur */
            margin-bottom: 2px; /* Petit espace sous l'emoji */
        }
        .weather-card p {
            margin: 2px 0;
            line-height: 1.2;
        }
        
        /* Styles pour la frise de pluie minute par minute (minutely) */
        .minutely-forecast-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 15px;
            padding: 8px;
            background-color: #f0f8ff;
            border-radius: 10px;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.05);
        }
        .minutely-timeline {
            display: flex;
            width: 100%;
            height: 30px;
            border-radius: 5px;
            overflow: hidden;
            margin-bottom: 3px;
        }
        .minute-block {
            flex-grow: 1;
            height: 100%;
            background-color: #e0f7fa;
            transition: background-color 0.3s ease;
            border-right: 1px solid rgba(255,255,255,0.2);
        }
        .minute-block:last-child {
            border-right: none;
        }
        .timeline-labels {
            position: relative; /* Parent pour le positionnement absolu des labels */
            width: 100%; /* Prend toute la largeur disponible */
            height: auto; /* Hauteur ajustée au contenu */
            font-size: 0.65em;
            color: #555;
        }
        .timeline-label {
            position: absolute; /* Positionnement absolu */
            top: 0; /* Aligné en haut du conteneur des labels */
            white-space: nowrap; /* Empêche le texte de passer à la ligne */
        }

        /* Styles pour les prévisions journalières (daily) */
        .daily-forecast {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            justify-content: center;
            margin-top: 15px;
            padding: 5px;
            box-sizing: border-box;
        }
        .day-card {
            border-radius: 8px;
            padding: 10px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            text-align: center;
            font-size: 0.85em;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100px;
            box-sizing: border-box;
            position: relative; /* Pour positionner l'icône d'alerte */
        }
        /* Style pour les emojis météo dans les cartes journalières */
        .day-card .weather-emoji {
            font-size: 2.5em; /* Grande taille pour les emojis */
            line-height: 1;
            margin-bottom: 2px;
        }

        /* Styles pour la section de saisie de lieu (inchangés) */
        .location-input-section {
            background-color: var(--input-section-bg); /* Utilise la variable */
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
        }
        .location-input-section input[type="text"] {
            padding: 10px;
            font-size: 1.1em;
            width: 80%;
            max-width: 300px;
        }
        
        /* Styles pour la liste de sélection de villes (inchangés) */
        #city-selection-results {
            margin-top: 15px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-height: 200px;
            overflow-y: auto;
            padding: 10px;
        }
        
        /* Styles pour les alertes */
        #weather-alerts-section { /* Nouveau conteneur pour la section d'alertes */
            margin-top: 20px;
            padding: 10px;
            border-radius: 15px;
            background-color: #ffffff; /* Fond blanc pour la section */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            text-align: left;
            max-width: 100%;
            margin-left: auto;
            margin-right: auto;
        }

        /* Le style du section-title est maintenant global, pas besoin de le redéfinir ici */
        #weather-alerts-section .section-title {
            margin-top: 0; /* Pas de marge en haut pour le titre de la section */
        }

        .alert-item {
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 8px;
            font-size: 0.9em;
            line-height: 1.4;
            border-left: 5px solid; /* Bordure colorée pour la gravité */
            background-color: var(--card-bg); /* Utilise la couleur de carte du thème */
        }

        .alert-item:last-child {
            margin-bottom: 0;
        }

        .alert-item h3 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 1.1em;
            font-weight: bold;
        }

        .alert-item p {
            margin: 0 0 5px 0;
        }

        /* Couleurs des alertes selon la gravité */
        .alert-minor { border-left-color: #4CAF50; } /* Vert */
        .alert-moderate { border-left-color: #FFC107; } /* Jaune */
        .alert-severe { border-left-color: #F44336; } /* Rouge */
        .alert-extreme { border-left-color: #D32F2F; } /* Rouge foncé */
        .alert-unknown { border-left-color: #9E9E9E; } /* Gris */

        /* Style pour l'icône d'alerte sur les cartes */
        .alert-icon {
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 1.5em; /* Taille de l'emoji alerte */
            cursor: pointer;
            text-decoration: none; /* Enlève le soulignement du lien */
            color: inherit; /* Hérite la couleur du texte parent */
            transition: transform 0.2s ease;
        }
        .alert-icon:hover {
            transform: scale(1.2);
        }

        /* Styles pour les sections dépliables */
        .collapsible-section {
            margin-bottom: 10px;
            border-radius: 15px;
            overflow: hidden; /* Cache le contenu quand max-height est 0 */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            background-color: #ffffff;
        }

        .collapsible-toggle {
            cursor: pointer;
            background-color: transparent; /* Pas de fond */
            color: #2196F3; /* Couleur de texte bleue */
            font-size: 1.8em; /* Taille de police du section-title */
            font-weight: bold;
            display: flex;
            justify-content: space-between; /* Aligne le texte à gauche et l'icône à droite */
            align-items: center;
            border-bottom: 2px solid #2196F3; /* Bordure inférieure bleue */
            padding: 15px 15px 5px 15px; /* Ajuste le padding pour l'espace sur les côtés */
            border-radius: 0; /* Pas de coins arrondis spécifiques pour le toggle */
            transition: background-color 0.3s ease, color 0.3s ease;
            width: 100%; /* S'assure que le toggle prend toute la largeur */
            box-sizing: border-box; /* Inclut le padding dans la largeur */
        }
        .collapsible-toggle:hover {
            background-color: transparent; /* Pas de changement de fond au survol */
            color: #1976D2; /* Un bleu légèrement plus foncé au survol */
        }

        .toggle-title-text { /* Nouvelle classe pour le texte du titre */
            flex-grow: 1; /* Permet au texte de prendre l'espace disponible */
            text-align: center; /* Centre le texte dans l'espace disponible */
        }

        .toggle-icon {
            font-size: 0.8em;
            transition: transform 0.3s ease;
            color: #333; /* Couleur plus foncée pour la flèche pour meilleure visibilité */
            /* margin-left: 10px; -> N'est plus nécessaire avec justify-content: space-between */
        }
        .collapsible-toggle.expanded .toggle-icon {
            transform: rotate(180deg);
        }

        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease-out; /* Transition douce pour le dépliage */
            padding: 0 10px; /* Padding latéral pour le contenu */
            background-color: #ffffff; /* Fond blanc pour le contenu déplié */
            border-radius: 0 0 15px 15px; /* Coins arrondis en bas */
        }
        .collapsible-content.expanded {
            /* max-height sera défini par JS */
            padding-bottom: 10px; /* Ajoute un peu de padding en bas quand déplié */
        }

        /* Styles spécifiques pour la section protégée par mot de passe */
        .password-prompt {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            padding: 20px;
            background-color: var(--input-section-bg);
            border-radius: 10px;
            margin: 10px auto;
            max-width: 300px;
        }
        .password-prompt input[type="password"] {
            padding: 8px;
            font-size: 1em;
            border: 1px solid var(--input-border);
            border-radius: 5px;
            width: 100%;
            box-sizing: border-box;
        }
        .password-prompt button {
            padding: 10px 20px;
            background-color: var(--button-bg);
            color: var(--button-text);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s ease;
        }
        .password-prompt button:hover {
            background-color: #6A1B9A; /* Un peu plus foncé */
        }
        .password-error {
            color: #e53935;
            font-size: 0.9em;
            margin-top: 5px;
        }


        /* Media queries pour les écrans plus grands (desktop) */
        @media (min-width: 768px) {
            body {
                margin: 20px;
            }
            .main-header-section {
                flex-direction: row;
                justify-content: space-between;
                align-items: center;
                padding: 15px 20px;
            }
            .header-content-left {
                align-items: center;
                text-align: center;
                flex-grow: 1;
                padding-right: 20px;
            }
            h1 { font-size: 2.5em; margin-bottom: 10px; }
            #current-location-display { font-size: 1.8em; margin-bottom: 15px; }

            .button-container {
                flex-direction: row;
                gap: 15px;
                margin-bottom: 0;
            }
            .weather-button {
                padding: 12px 25px;
                font-size: 1.2em;
            }

            #map-container {
                width: 200px;
                height: 200px;
                margin-top: 0;
                flex-shrink: 0;
            }

            .container { padding: 20px; }
            .section-title { font-size: 1.8em; margin-top: 30px; }

            .hourly-forecast {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                gap: 10px;
                padding: 10px;
            }
            .weather-card {
                padding: 15px;
                font-size: 1.1em;
                min-height: 90px;
            }
            /* Ajustement pour les emojis sur desktop */
            .weather-card .weather-emoji {
                font-size: 3em; /* Plus grande taille pour les emojis sur desktop */
            }
            .weather-card p { margin: 5px 0; } /* Réinitialise les marges pour desktop */
            .weather-card .temp { font-size: 1.4em; }
            .weather-card .feels-like { font-size: 0.9em; }
            .weather-card .time { font-size: 0.9em; }
            .weather-card .precipitation { font-size: 0.9em; }

            .minutely-forecast-container { padding: 10px; margin-top: 20px; }
            .minutely-timeline { height: 40px; margin-bottom: 5px; }
            .timeline-labels { font-size: 0.8em; }

            .daily-forecast {
                grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
                gap: 15px;
                margin-top: 20px;
            }
            .day-card {
                padding: 15px;
                font-size: 0.9em;
                min-height: 120px;
            }
            /* Ajustement pour les emojis sur desktop */
            .day-card .weather-emoji {
                font-size: 3em; /* Plus grande taille pour les emojis sur desktop */
            }
            .day-card .temp-range { font-size: 1.3em; }
            .day-card .feels-like { font-size: 0.9em; }
            .day-card .date { font-size: 0.9em; }
        }
    </style>
</head>
<body>
    <div class="main-header-section">
        <div class="header-content-left">
            <h1>Météo rapide ! ☀️☁️☔</h1>
            <div id="current-location-display">Chargement...</div>
            <div class="button-container">
                <button id="btn-locate-me" class="weather-button">Météo ici ! 📍</button>
                <button id="btn-choose-location" class="weather-button">Météo ailleurs... 🌍</button>
                <button id="btn-back-to-charvieu" class="weather-button">Charvieu-Chavagneux 🏠</button>
                <button id="btn-chatel" class="weather-button">Météo Châtel 🏔️</button> <!-- Nouveau bouton pour Châtel -->
            </div>
        </div>
        <div id="map-container">
            <iframe id="map-iframe" src="" allowfullscreen="" loading="lazy" referrerpolicy="no-referrer-when-downgrade"></iframe>
        </div>
    </div>

    <div id="location-input-section" class="location-input-section">
        <input type="text" id="city-input" placeholder="Tape le nom d'une ville (ex: Paris)">
        <button id="btn-search-location">Chercher !</button>
        <p id="location-error-message" class="error-message"></p>
        <div id="city-selection-results">
            <!-- Les options de ville seront ajoutées ici -->
        </div>
    </div>

    <!-- Nouvelle section: Que s'est-il passé dans les 24h précédentes -->
    <div class="collapsible-section">
        <h2 class="section-title collapsible-toggle" data-target="previous-hourly-forecast-content">
            <span class="toggle-title-text">Que s'est-il passé dans les 24h précédentes ? 🕰️</span> <span class="toggle-icon">▼</span>
        </h2>
        <div id="previous-hourly-forecast-content" class="collapsible-content container">
            <!-- Contenu initial avec mot de passe -->
            <div id="password-prompt-container" class="password-prompt">
                <p>Pour accéder aux données historiques, entre le mot de passe :</p>
                <input type="password" id="password-input" placeholder="Mot de passe">
                <button id="btn-unlock-history">Déverrouiller</button>
                <p id="password-error-message" class="password-error"></p>
            </div>
            <!-- Les données historiques seront chargées ici après validation -->
            <div id="historical-data-display" class="hourly-forecast" style="display: none;">
                <p class="error-message" id="previous-hourly-loading"></p>
            </div>
        </div>
    </div>

    <!-- Section: La pluie dans l'heure qui vient ! -->
    <div class="collapsible-section">
        <h2 class="section-title collapsible-toggle expanded" data-target="minutely-forecast-content">
            <span class="toggle-title-text">La pluie dans l'heure qui vient ! 💧</span> <span class="toggle-icon">▲</span>
        </h2>
        <div id="minutely-forecast-content" class="collapsible-content container expanded">
            <div id="minutely-forecast" class="minutely-forecast-container">
                <p class="error-message" id="minutely-loading">Chargement des prévisions de pluie minute par minute...</p>
            </div>
        </div>
    </div>

    <!-- Section: Les 24h à venir ! -->
    <div class="collapsible-section">
        <h2 class="section-title collapsible-toggle expanded" data-target="hourly-forecast-content">
            <span class="toggle-title-text">Les 24h à venir ! ⏰</span> <span class="toggle-icon">▲</span>
        </h2>
        <div id="hourly-forecast-content" class="collapsible-content container expanded">
            <div id="hourly-forecast" class="hourly-forecast">
                <p class="error-message" id="hourly-loading">Chargement de la météo heure par heure...</p>
            </div>
        </div>
    </div>

    <!-- Section: Les jours suivants (J+1 à J+7) ! -->
    <div class="collapsible-section">
        <h2 class="section-title collapsible-toggle" data-target="daily-forecast-content">
            <span class="toggle-title-text">Les jours suivants (J+1 à J+7) ! 🗓️</span> <span class="toggle-icon">▼</span>
        </h2>
        <div id="daily-forecast-content" class="collapsible-content container">
            <div id="daily-forecast" class="daily-forecast">
                <p class="error-message" id="daily-loading">Chargement des prévisions des prochains jours...</p>
            </div>
        </div>
    </div>

    <!-- Section pour les alertes météo, placée tout en bas -->
    <div class="collapsible-section" id="weather-alerts-section"> <!-- Ajout de l'ID ici pour le scroll -->
        <h2 class="section-title collapsible-toggle" data-target="weather-alerts-content">
            <span class="toggle-title-text">Alertes Météo ! ⚠️</span> <span class="toggle-icon">▼</span>
        </h2>
        <div id="weather-alerts-content" class="collapsible-content container">
            <div id="weather-alerts">
                <p class="error-message" id="alerts-loading">Chargement des alertes météo...</p>
            </div>
        </div>
    </div>

    <script>
        const API_KEY = '51aebd101995305de8a90d128247bdad'; // Ta clé API OpenWeatherMap
        const DEFAULT_LAT = 45.7167; // Latitude de Charvieu-Chavagneux
        const DEFAULT_LON = 5.15;    // Longitude de Charvieu-Chavagneux
        const DEFAULT_LOCATION_NAME = 'Charvieu-Chavagneux'; // Nom mis à jour

        // Constantes pour Châtel
        const CHATEL_LAT = 46.267495226616674;
        const CHATEL_LON = 6.840705801969403;
        const CHATEL_LOCATION_NAME = 'Châtel, Haute-Savoie, France';


        const LANG = 'fr';   // Langue des résultats
        const UNITS = 'metric'; // Unités métriques (Celsius)

        // Flag pour simuler les appels API
        const SIMULATE_API_CALLS = false; // Désactivé pour les vrais appels API

        // Éléments du DOM
        const body = document.body;
        const currentLocationDisplay = document.getElementById('current-location-display');
        const btnLocateMe = document.getElementById('btn-locate-me');
        const btnChooseLocation = document.getElementById('btn-choose-location');
        const btnBackToCharvieu = document.getElementById('btn-back-to-charvieu');
        const btnChatel = document.getElementById('btn-chatel'); // Nouveau bouton
        const locationInputSection = document.getElementById('location-input-section');
        const cityInput = document.getElementById('city-input');
        const btnSearchLocation = document.getElementById('btn-search-location');
        const locationErrorMessage = document.getElementById('location-error-message');
        const citySelectionResults = document.getElementById('city-selection-results');
        const mapIframe = document.getElementById('map-iframe');
        const weatherAlertsContainer = document.getElementById('weather-alerts');
        
        // Nouveaux éléments pour la section historique protégée
        const passwordPromptContainer = document.getElementById('password-prompt-container');
        const passwordInput = document.getElementById('password-input');
        const btnUnlockHistory = document.getElementById('btn-unlock-history');
        const passwordErrorMessage = document.getElementById('password-error-message');
        const historicalDataDisplay = document.getElementById('historical-data-display');
        const previousHourlyLoadingMessage = document.getElementById('previous-hourly-loading');


        // Variable globale pour stocker les alertes
        let globalAlerts = [];
        // Variable pour stocker la localisation actuelle (lat/lon) pour les appels historiques
        let currentLat = DEFAULT_LAT;
        let currentLon = DEFAULT_LON;

        // --- Fonctions utilitaires ---

        // Fonction pour obtenir les icônes météo (maintenant des emojis)
        function getWeatherIcon(iconCode) {
            switch(iconCode) {
                case "01d": return "☀️"; // Clear sky (day)
                case "01n": return "🌙"; // Clear sky (night)
                case "02d": return "🌤️"; // Few clouds (day)
                case "02n": return "☁️🌙"; // Few clouds (night)
                case "03d":
                case "03n": return "☁️"; // Scattered clouds
                case "04d":
                case "04n": return "☁️☁️"; // Broken clouds / Overcast
                case "09d":
                case "09n": return "🌧️"; // Shower rain
                case "10d":
                case "10n": return "☔"; // Rain
                case "11d":
                case "11n": return "⛈️"; // Thunderstorm
                case "13d":
                case "13n": return "❄️"; // Snow
                case "50d":
                case "50n": return "🌫️"; // Mist
                default: return "❓"; // Default icon
            }
        }

        // Fonction pour déterminer la classe de thème en fonction de l'icône OpenWeatherMap
        function getThemeClass(iconCode) {
            const isDay = iconCode.endsWith('d');
            const baseIcon = iconCode.slice(0, -1); // e.g., "01" from "01d"

            switch (baseIcon) {
                case "01": return isDay ? "theme-sunny" : "theme-night";
                case "02": return isDay ? "theme-cloudy" : "theme-night";
                case "03": return "theme-cloudy";
                case "04": return "theme-cloudy";
                case "09": return "theme-rainy";
                case "10": return "theme-rainy";
                case "11": return "theme-thunderstorm";
                case "13": return "theme-snowy";
                case "50": return "theme-mist";
                default: return "theme-sunny"; // Fallback
            }
        }

        // Fonction pour appliquer le thème
        function applyTheme(themeClassName) {
            const themeClasses = [
                "theme-sunny", "theme-cloudy", "theme-rainy", "theme-snowy",
                "theme-thunderstorm", "theme-mist", "theme-night"
            ];
            themeClasses.forEach(cls => body.classList.remove(cls));
            body.classList.add(themeClassName);
        }

        // Fonctions de formatage de date/heure
        function formatTime(timestamp) {
            const date = new Date(timestamp * 1000);
            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            return `${hours}h${minutes}`;
        }

        function formatDate(timestamp) {
            const date = new Date(timestamp * 1000);
            const options = { weekday: 'short', day: 'numeric', month: 'short' };
            return date.toLocaleDateString('fr-FR', options);
        }

        function formatDateTime(timestamp) {
            const date = new Date(timestamp * 1000);
            const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric', hour: '2-digit', minute: '2-digit' };
            return date.toLocaleDateString('fr-FR', options);
        }

        // Fonction pour vérifier si une période est couverte par une alerte
        function isPeriodAffectedByAlert(timestamp) {
            const timeMs = timestamp * 1000;
            for (const alert of globalAlerts) {
                const alertStartMs = alert.start * 1000;
                const alertEndMs = alert.end * 1000;
                if (timeMs >= alertStartMs && timeMs <= alertEndMs) {
                    return true;
                }
            }
            return false;
        }

        // --- Fonctions d'affichage des données météo ---

        function displayAlerts(alertsData) {
            weatherAlertsContainer.innerHTML = '';
            if (!alertsData || alertsData.length === 0) {
                weatherAlertsContainer.innerHTML = '<p>Aucune alerte météo active pour le moment. Tout va bien ! 😊</p>';
                return;
            }
            alertsData.forEach(alert => {
                const alertDiv = document.createElement('div');
                const severityClass = `alert-${alert.severity ? alert.severity.toLowerCase() : 'unknown'}`;
                alertDiv.className = `alert-item ${severityClass}`;
                const startDate = formatDateTime(alert.start);
                const endDate = formatDateTime(alert.end);
                alertDiv.innerHTML = `
                    <h3>${alert.event}</h3>
                    <p><strong>De :</strong> ${alert.sender_name || 'Inconnu'}</p>
                    <p><strong>Début :</strong> ${startDate}</p>
                    <p><strong>Fin :</strong> ${endDate}</p>
                    <p><strong>Description :</strong> ${alert.description || 'Pas de description disponible.'}</p>
                    ${alert.instruction ? `<p><strong>Instructions :</strong> ${alert.instruction}</p>` : ''}
                `;
                weatherAlertsContainer.appendChild(alertDiv);
            });
        }

        function displayMinutelyForecast(minutelyData) {
            const minutelyContainer = document.getElementById('minutely-forecast');
            minutelyContainer.innerHTML = '';
            if (!minutelyData || minutelyData.length === 0) {
                minutelyContainer.innerHTML = '<p class="precipitation">Pas de prévisions de pluie minute par minute disponibles pour le moment.</p>';
                return;
            }
            const timelineDiv = document.createElement('div');
            timelineDiv.className = 'minutely-timeline';
            for (let i = 0; i < 60; i++) {
                const minute = minutelyData[i];
                if (!minute) continue;
                const precipitation = minute.precipitation;
                let backgroundColor = '#e0f7fa';
                if (precipitation > 0 && precipitation <= 0.5) {
                    backgroundColor = '#bbdefb';
                } else if (precipitation > 0.5 && precipitation <= 2) {
                    backgroundColor = '#90caf9';
                } else if (precipitation > 2 && precipitation <= 5) {
                    backgroundColor = '#64b5f6';
                } else if (precipitation > 5) {
                    backgroundColor = '#42a5f5';
                }
                const minuteBlock = document.createElement('div');
                minuteBlock.className = 'minute-block';
                minuteBlock.title = `Dans ${i} min : ${precipitation.toFixed(1)} mm/h`;
                minuteBlock.style.backgroundColor = backgroundColor;
                timelineDiv.appendChild(minuteBlock);
            }
            minutelyContainer.appendChild(timelineDiv);
            const labelsDiv = document.createElement('div');
            labelsDiv.className = 'timeline-labels';
            const now = new Date();
            for (let i = 0; i <= 60; i += 10) {
                const labelSpan = document.createElement('span');
                labelSpan.className = 'timeline-label';
                const positionPercentage = (i / 60) * 100;
                labelSpan.style.left = `${positionPercentage}%`;
                if (i === 0) {
                    labelSpan.style.transform = 'translateX(0%)';
                    labelSpan.style.textAlign = 'left';
                } else if (i === 60) {
                    labelSpan.style.transform = 'translateX(-100%)';
                    labelSpan.style.textAlign = 'right';
                } else {
                    labelSpan.style.transform = 'translateX(-50%)';
                    labelSpan.style.textAlign = 'center';
                }
                const futureTime = new Date(now.getTime() + i * 60 * 1000);
                const hours = futureTime.getHours().toString().padStart(2, '0');
                const minutes = futureTime.getMinutes().toString().padStart(2, '0');
                labelSpan.textContent = `${hours}h${minutes}`;
                labelsDiv.appendChild(labelSpan);
            }
            minutelyContainer.appendChild(labelsDiv);
        }

        function displayHourlyForecast(hourlyData, containerElement) {
            containerElement.innerHTML = ''; // Clear previous content

            if (!hourlyData || hourlyData.length === 0) {
                containerElement.innerHTML = '<p class="error-message">Pas de données horaires disponibles.</p>'; // Message générique
                return;
            }

            // Sort data by timestamp to ensure chronological order
            hourlyData.sort((a, b) => a.dt - b.dt);

            // Limite l'affichage aux 24 premières heures
            hourlyData.slice(0, 24).forEach(hour => {
                // Ensure rain and snow volumes are numbers before calling toFixed
                const rainVolume = hour.rain && typeof hour.rain['1h'] === 'number' ? hour.rain['1h'].toFixed(1) : '0';
                const snowVolume = hour.snow && typeof hour.snow['1h'] === 'number' ? hour.snow['1h'].toFixed(1) : '0';
                
                let precipitationInfo = '';
                if (parseFloat(rainVolume) > 0) {
                    precipitationInfo += `<p class="precipitation">Pluie: ${rainVolume} mm</p>`;
                }
                if (parseFloat(snowVolume) > 0) {
                    precipitationInfo += `<p class="precipitation">Neige: ${snowVolume} mm</p>`;
                }

                const alertIconHtml = isPeriodAffectedByAlert(hour.dt) ? 
                    `<a href="#weather-alerts-section" class="alert-icon" title="Voir l'alerte météo">⚠️</a>` : '';

                const card = `
                    <div class="weather-card">
                        ${alertIconHtml}
                        <p class="time">${formatTime(hour.dt)}</p>
                        <span class="weather-emoji">${getWeatherIcon(hour.weather[0].icon)}</span>
                        <p class="temp">${Math.round(hour.temp)}°C</p>
                        <p class="feels-like">Ressenti: ${Math.round(hour.feels_like)}°C</p>
                        <p>${hour.weather[0].description}</p>
                        ${precipitationInfo}
                    </div>
                `;
                containerElement.innerHTML += card;
            });
        }

        function displayDailyForecast(dailyData) {
            const dailyContainer = document.getElementById('daily-forecast');
            dailyContainer.innerHTML = '';
            if (!dailyData || dailyData.length === 0) {
                dailyContainer.innerHTML = '<p class="error-message">Pas de prévisions journalières disponibles.</p>';
                return;
            }

            for (let i = 0; i < 7 && i < dailyData.length; i++) {
                const day = dailyData[i];
                if (!day) continue;

                // Ensure rain and snow volumes are numbers before calling toFixed
                const rainVolume = typeof day.rain === 'number' ? day.rain.toFixed(1) : '0';
                const snowVolume = typeof day.snow === 'number' ? day.snow.toFixed(1) : '0';

                let precipitationInfo = '';
                if (parseFloat(rainVolume) > 0) {
                    precipitationInfo += `<p class="precipitation">Pluie: ${rainVolume} mm</p>`;
                }
                if (parseFloat(snowVolume) > 0) {
                    precipitationInfo += `<p class="precipitation">Neige: ${snowVolume} mm</p>`;
                }

                const alertIconHtml = isPeriodAffectedByAlert(day.dt) ?
                    `<a href="#weather-alerts-section" class="alert-icon" title="Voir l'alerte météo">⚠️</a>` : '';

                const card = `
                    <div class="day-card">
                        ${alertIconHtml}
                        <p class="date">${formatDate(day.dt)}</p>
                        <span class="weather-emoji">${getWeatherIcon(day.weather[0].icon)}</span>
                        <p class="temp-range">
                            ${Math.round(day.temp.min)}°C à ${Math.round(day.temp.max)}°C
                        </p>
                        <p class="feels-like">Ressenti: ${Math.round(day.feels_like.day)}°C</p>
                        <p>${day.weather[0].description}</p>
                        ${precipitationInfo}
                    </div>
                `;
                dailyContainer.innerHTML += card;
            }
        }

        // --- Fonctions de gestion des données API (simulées ou réelles) ---

        // Données simulées pour les appels API
        const dummyMainData = (lat, lon, now) => ({
            current: {
                dt: now,
                temp: 20 + Math.sin(now / 3600 / 24 * Math.PI) * 5,
                feels_like: 19 + Math.sin(now / 3600 / 24 * Math.PI) * 5,
                weather: [{ id: 800, main: "Clear", description: "ciel clair (simulé)", icon: "01d" }],
                rain: {},
                snow: {}
            },
            minutely: Array(60).fill(0).map((_, i) => ({ dt: now + i * 60, precipitation: i < 10 && i % 3 === 0 ? 0.2 + Math.random() * 0.5 : 0 })),
            hourly: Array(48).fill(0).map((_, i) => ({ // Maintenu à 48 pour simuler la réponse complète de l'API
                dt: now + (i + 1) * 3600,
                temp: 20 + Math.sin((now + (i + 1) * 3600) / 3600 / 12 * Math.PI) * 8, // Simule cycle jour/nuit
                feels_like: 19 + Math.sin((now + (i + 1) * 3600) / 3600 / 12 * Math.PI) * 8,
                weather: [{ id: 800, main: "Clouds", description: "nuageux (simulé)", icon: "04d" }],
                rain: i % 5 === 0 ? { '1h': parseFloat((0.5 + Math.random() * 2).toFixed(1)) } : {}, // Ensure number
                snow: {},
                pressure: 1010 + Math.random() * 10,
                humidity: 70 + Math.random() * 20,
                wind_speed: 5 + Math.random() * 5,
                wind_deg: Math.floor(Math.random() * 360),
                visibility: 10000,
                clouds: Math.floor(Math.random() * 100),
                uvi: (Math.random() * 5).toFixed(1)
            })),
            daily: Array(7).fill(0).map((_, i) => ({
                dt: now + (i + 1) * 24 * 3600,
                temp: { min: 15 + i + Math.random() * 2, max: 25 + i + Math.random() * 3 },
                feels_like: { day: 20 + i + Math.random() * 2 },
                weather: [{ id: 800, main: "Clear", description: "ensoleillé (simulé)", icon: "01d" }],
                rain: i % 3 === 0 ? parseFloat((2 + Math.random() * 5).toFixed(1)) : 0, // Ensure number
                snow: 0
            })),
            alerts: [
                {
                    event: "Alerte test (simulée)",
                    sender_name: "Service Météo Simulé",
                    start: now + 3600, // Starts in 1 hour
                    end: now + 72000, // Ends in 20 hours
                    description: "Ceci est une alerte météo simulée pour des tests. Aucune condition réelle.",
                    instruction: "Restez vigilant (simulé)."
                }
            ]
        });

        // Données simulées pour un appel historique horaire unique
        const dummyHistoricalSingleHourData = (lat, lon, timestamp) => ({
            lat: lat,
            lon: lon,
            timezone: "Europe/Paris",
            timezone_offset: 7200,
            data: [
                {
                    dt: timestamp, // Crucial: use the requested timestamp
                    temp: 15 + Math.random() * 10, // Random temp
                    feels_like: 14 + Math.random() * 10,
                    weather: [{ id: 800, main: "Clouds", description: "couvert (simulé)", icon: "04n" }],
                    rain: Math.random() > 0.8 ? { '1h': parseFloat((Math.random() * 2).toFixed(1)) } : {}, // Ensure number
                    snow: {},
                    pressure: 1010 + Math.random() * 10,
                    humidity: 70 + Math.random() * 20,
                    wind_speed: 5 + Math.random() * 5,
                    wind_deg: Math.floor(Math.random() * 360),
                    visibility: 10000,
                    clouds: Math.floor(Math.random() * 100),
                    uvi: (Math.random() * 5).toFixed(1)
                }
            ]
        });

        // Fonction pour simuler un délai réseau
        function simulateNetworkDelay(minMs = 200, maxMs = 800) {
            return new Promise(resolve => setTimeout(resolve, Math.random() * (maxMs - minMs) + minMs));
        }

        async function getHistoricalHourlyData(lat, lon) {
            const now = Math.floor(Date.now() / 1000);
            const historicalHourlyData = [];

            console.log("Fetching historical data for the last 24 hours...");

            if (SIMULATE_API_CALLS) {
                await simulateNetworkDelay(); // Simuler le délai réseau pour l'ensemble de la récupération
                for (let i = 0; i < 24; i++) {
                    const timestamp = now - ((23 - i) * 3600); // Start from 23 hours ago, up to current hour
                    const data = dummyHistoricalSingleHourData(lat, lon, timestamp);
                    if (data.data && data.data.length > 0 && data.data[0]) {
                        historicalHourlyData.push(data.data[0]);
                    }
                }
                console.log(`    Simulated data for 24 hours generated.`);
            } else {
                // Cette partie du code fera 24 appels réels
                for (let i = 0; i < 24; i++) {
                    const timestamp = now - ((23 - i) * 3600); // Start from 23 hours ago, up to current hour
                    const url = `https://api.openweathermap.org/data/3.0/onecall/timemachine?lat=${lat}&lon=${lon}&dt=${timestamp}&appid=${API_KEY}&units=${UNITS}&lang=${LANG}`;
                    try {
                        console.log(`  Requesting data for: ${new Date(timestamp * 1000).toISOString()}`);
                        const response = await fetch(url);
                        if (!response.ok) {
                            console.error(`    HTTP error! status: ${response.status} for timestamp ${timestamp}. URL: ${url}`);
                            continue; 
                        }
                        const data = await response.json();
                        console.log(`    Raw response for timestamp ${timestamp}:`, data);

                        if (data.data && data.data.length > 0 && data.data[0]) {
                            historicalHourlyData.push(data.data[0]);
                            console.log(`    Successfully processed data for ${new Date(timestamp * 1000).toISOString()}`);
                        } else {
                            console.warn(`    No valid data[0] found for timestamp ${timestamp}. Raw response:`, data);
                        }
                    } catch (error) {
                        console.error(`    Error fetching data for timestamp ${timestamp}:`, error);
                    }
                }
            }

            historicalHourlyData.sort((a, b) => a.dt - b.dt);
            console.log("Final collected historical hourly data:", historicalHourlyData);
            return historicalHourlyData;
        }


        // Fonction principale pour récupérer et afficher la météo
        async function updateWeatherForLocation(lat, lon, locationName) {
            currentLat = lat; // Met à jour la latitude globale
            currentLon = lon; // Met à jour la longitude globale

            currentLocationDisplay.textContent = `${locationName}`;
            mapIframe.src = `https://maps.google.com/maps?q=${lat},${lon}&z=10&output=embed`;

            // Réinitialiser les sections
            weatherAlertsContainer.innerHTML = '<p class="error-message" id="alerts-loading">Chargement des alertes météo...</p>';
            document.getElementById('minutely-forecast').innerHTML = '<p class="error-message" id="minutely-loading">Chargement des prévisions de pluie minute par minute...</p>';
            document.getElementById('hourly-forecast').innerHTML = '<p class="error-message" id="hourly-loading">Chargement de la météo heure par heure...</p>';
            document.getElementById('daily-forecast').innerHTML = '<p class="error-message" id="daily-loading">Chargement des prévisions des prochains jours...</p>';
            
            // Masquer les données historiques et afficher le prompt de mot de passe
            historicalDataDisplay.style.display = 'none';
            passwordPromptContainer.style.display = 'flex';
            passwordInput.value = '';
            passwordErrorMessage.textContent = '';
            previousHourlyLoadingMessage.textContent = ''; // Clear any previous loading message

            locationErrorMessage.textContent = '';
            citySelectionResults.innerHTML = '';
            citySelectionResults.style.display = 'none';

            try {
                let mainData;
                if (SIMULATE_API_CALLS) {
                    await simulateNetworkDelay(); // Simuler le délai réseau
                    mainData = dummyMainData(lat, lon, Math.floor(Date.now() / 1000));
                    console.log("Simulated Main API Data:", mainData);
                } else {
                    const mainUrl = `https://api.openweathermap.org/data/3.0/onecall?lat=${lat}&lon=${lon}&appid=${API_KEY}&units=${UNITS}&lang=${LANG}`;
                    const mainResponse = await fetch(mainUrl);
                    if (!mainResponse.ok) {
                        throw new Error(`Erreur HTTP ! Statut: ${mainResponse.status} pour les données principales`);
                    }
                    mainData = await mainResponse.json();
                    console.log("Main API Data (current, forecast, alerts):", mainData);
                }

                // Stocke les alertes globalement
                globalAlerts = mainData.alerts || [];

                // Appliquer le thème basé sur la météo actuelle
                if (mainData.current && mainData.current.weather && mainData.current.weather.length > 0) {
                    const currentIconCode = mainData.current.weather[0].icon;
                    const themeClassName = getThemeClass(currentIconCode);
                    applyTheme(themeClassName);
                } else {
                    applyTheme("theme-sunny"); // Fallback
                }

                // Afficher les sections
                displayAlerts(globalAlerts);
                displayMinutelyForecast(mainData.minutely); 
                displayHourlyForecast(mainData.hourly, document.getElementById('hourly-forecast')); // Futures 24h
                displayDailyForecast(mainData.daily);
                
            } catch (error) {
                console.error('Problème pour récupérer les données météo principales :', error);
                // Afficher les messages d'erreur pour toutes les sections
                weatherAlertsContainer.innerHTML = '<p class="error-message">Impossible de charger les alertes météo.</p>';
                document.getElementById('minutely-forecast').innerHTML = '<p class="error-message">Impossible de charger la frise de pluie. Vérifie la connexion ou la clé API.</p>';
                document.getElementById('hourly-forecast').innerHTML = '<p class="error-message">Oh non ! Je n\'arrive pas à trouver la météo pour le moment. Demande à un adulte de vérifier ma connexion Internet ou ma clé météo !</p>';
                document.getElementById('daily-forecast').innerHTML = '<p class="error-message">Impossible de charger les prévisions des prochains jours.</p>';
                currentLocationDisplay.textContent = `Météo pour ${locationName} (Erreur)`;
                applyTheme("theme-cloudy"); // Applique un thème neutre en cas d'erreur
            }
            
            // Re-initialiser les accordéons après le chargement du contenu
            setupCollapsibles();
            // Déplier les sections par default après le chargement initial
            expandSection('minutely-forecast-content');
            expandSection('hourly-forecast-content');
        }

        // Fonction pour obtenir le nom de la ville à partir des coordonnées (géocodage inverse)
        async function getCityNameFromCoordinates(lat, lon) {
            // Cette fonction peut toujours faire un VRAI appel API car elle est moins fréquente
            // et n'est pas la principale consommatrice de quota.
            // Si tu souhaites aussi la simuler, il faudra ajouter une logique similaire.
            if (SIMULATE_API_CALLS) {
                await simulateNetworkDelay();
                // Retourne un nom de ville simulé
                return `Ville simulée (${lat.toFixed(2)}, ${lon.toFixed(2)})`;
            }

            const reverseGeocodingUrl = `https://api.openweathermap.org/geo/1.0/reverse?lat=${lat}&lon=${lon}&limit=1&appid=${API_KEY}`;
            try {
                const response = await fetch(reverseGeocodingUrl);
                const data = await response.json();
                if (data.length > 0) {
                    return data[0].name + (data[0].state ? `, ${data[0].state}` : '') + (data[0].country ? `, ${data[0].country}` : '');
                }
            } catch (error) {
                console.error('Erreur lors du géocodage inverse :', error);
            }
            return null;
        }

        // --- Fonctions de gestion des événements des boutons ---

        btnLocateMe.addEventListener('click', () => {
            currentLocationDisplay.textContent = "Recherche de ta position...";
            locationErrorMessage.textContent = '';
            locationInputSection.style.display = 'none';
            citySelectionResults.innerHTML = '';
            citySelectionResults.style.display = 'none';

            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        const lat = position.coords.latitude;
                        const lon = position.coords.longitude;
                        getCityNameFromCoordinates(lat, lon).then(locationName => {
                            updateWeatherForLocation(lat, lon, locationName || "Ma position actuelle");
                        });
                    },
                    (error) => {
                        console.error('Erreur de géolocalisation :', error);
                        let errorMessage = 'Impossible de trouver ta position.';
                        if (error.code === error.PERMISSION_DENIED) {
                            errorMessage += '<br>Vérifie les réglages de localisation de ton navigateur ou de ton téléphone (autorise l\'accès à la géolocalisation pour cette page).';
                            errorMessage += '<br>Assure-toi aussi que la page est ouverte via HTTPS (adresse qui commence par "https://").';
                        } else if (error.code === error.POSITION_UNAVAILABLE) {
                            errorMessage += '<br>La position n\'est pas disponible.';
                        } else if (error.code === error.TIMEOUT) {
                            errorMessage += '<br>Le temps de recherche de la position est écoulé.';
                        }
                        locationErrorMessage.innerHTML = errorMessage;
                        currentLocationDisplay.textContent = "Position inconnue";
                        updateWeatherForLocation(DEFAULT_LAT, DEFAULT_LON, DEFAULT_LOCATION_NAME);
                    },
                    {
                        enableHighAccuracy: true,
                        timeout: 10000,
                        maximumAge: 0
                    }
                );
            } else {
                locationErrorMessage.textContent = 'Ton navigateur ne supporte pas la géolocalisation.';
                currentLocationDisplay.textContent = "Position inconnue";
                updateWeatherForLocation(DEFAULT_LAT, DEFAULT_LON, DEFAULT_LOCATION_NAME);
            }
        });

        btnChooseLocation.addEventListener('click', () => {
            if (locationInputSection.style.display === 'flex') {
                locationInputSection.style.display = 'none';
                locationErrorMessage.textContent = '';
                citySelectionResults.innerHTML = '';
                citySelectionResults.style.display = 'none';
            } else {
                locationInputSection.style.display = 'flex';
                cityInput.value = '';
                cityInput.focus();
                locationErrorMessage.textContent = '';
                citySelectionResults.innerHTML = '';
                citySelectionResults.style.display = 'none';
            }
        });

        btnSearchLocation.addEventListener('click', async () => {
            const cityName = cityInput.value.trim();
            if (cityName === '') {
                locationErrorMessage.textContent = 'Tape le nom d\'une ville, s\'il te plaît !';
                return;
            }

            locationErrorMessage.textContent = 'Recherche de la ville...';
            citySelectionResults.innerHTML = '';
            citySelectionResults.style.display = 'none';

            let geoData;
            if (SIMULATE_API_CALLS) {
                await simulateNetworkDelay();
                // Simule une réponse de géocodage
                geoData = [
                    { name: cityName, lat: DEFAULT_LAT + Math.random(), lon: DEFAULT_LON + Math.random(), country: "FR", state: "Simulé" },
                    { name: cityName + " (Autre)", lat: DEFAULT_LAT + Math.random() + 1, lon: DEFAULT_LON + Math.random() + 1, country: "FR", state: "Simulé" }
                ];
                if (cityName.toLowerCase() === "paris") { // Un cas spécifique pour Paris
                    geoData = [{ name: "Paris", lat: 48.8566, lon: 2.3522, country: "FR" }];
                } else if (cityName.toLowerCase() === "lyon") {
                    geoData = [{ name: "Lyon", lat: 45.7640, lon: 4.8357, country: "FR" }];
                } else if (Math.random() < 0.3) { // Simule aucun résultat parfois
                    geoData = [];
                }
            } else {
                const geocodingUrl = `https://api.openweathermap.org/geo/1.0/direct?q=${cityName}&limit=5&appid=${API_KEY}`;
                const response = await fetch(geocodingUrl);
                if (!response.ok) {
                    throw new Error(`Erreur HTTP lors de la recherche de la ville ! Statut: ${response.status}`);
                }
                geoData = await response.json();
            }

            if (geoData.length > 1) {
                locationErrorMessage.textContent = 'Plusieurs villes trouvées. Choisis celle que tu veux :';
                citySelectionResults.style.display = 'flex';

                geoData.forEach(city => {
                    const optionText = `${city.name}` + 
                                       (city.state ? `, ${city.state}` : '') + 
                                       (city.country ? `, ${city.country}` : '');
                    
                    const cityButton = document.createElement('button');
                    cityButton.className = 'city-option-button';
                    cityButton.textContent = optionText;
                    cityButton.addEventListener('click', () => {
                        updateWeatherForLocation(city.lat, city.lon, optionText);
                        locationInputSection.style.display = 'none';
                    });
                    citySelectionResults.appendChild(cityButton);
                });

            } else if (geoData.length === 1) {
                const lat = geoData[0].lat;
                const lon = geoData[0].lon;
                const foundCityName = geoData[0].name + 
                                      (geoData[0].state ? `, ${geoData[0].state}` : '') + 
                                      (geoData[0].country ? `, ${geoData[0].country}` : '');
                updateWeatherForLocation(lat, lon, foundCityName);
                locationInputSection.style.display = 'none';
            } else {
                locationErrorMessage.textContent = `Désolé, je n'ai pas trouvé la ville "${cityName}". Essaie encore !`;
            }
        });

        btnBackToCharvieu.addEventListener('click', () => {
            updateWeatherForLocation(DEFAULT_LAT, DEFAULT_LON, DEFAULT_LOCATION_NAME);
            locationInputSection.style.display = 'none';
            citySelectionResults.innerHTML = '';
            citySelectionResults.style.display = 'none';
        });

        // Nouvel événement pour le bouton Châtel
        btnChatel.addEventListener('click', () => {
            updateWeatherForLocation(CHATEL_LAT, CHATEL_LON, CHATEL_LOCATION_NAME);
            locationInputSection.style.display = 'none';
            citySelectionResults.innerHTML = '';
            citySelectionResults.style.display = 'none';
        });

        // --- Fonctions pour les sections dépliables ---
        function setupCollapsibles() {
            document.querySelectorAll('.collapsible-toggle').forEach(toggle => {
                // Remove existing listeners to prevent duplicates on re-render
                toggle.removeEventListener('click', handleCollapsibleToggle);
                toggle.addEventListener('click', handleCollapsibleToggle);
            });
        }

        async function handleCollapsibleToggle(event) {
            const toggle = event.currentTarget;
            const targetId = toggle.dataset.target;
            const content = document.getElementById(targetId);
            const icon = toggle.querySelector('.toggle-icon');

            if (content.style.maxHeight && content.style.maxHeight !== "0px") {
                // Section is currently expanded, collapse it
                content.style.maxHeight = "0px";
                icon.textContent = '▼';
                toggle.classList.remove('expanded');
                content.classList.remove('expanded');
            } else {
                // Section is currently collapsed, expand it
                content.style.maxHeight = content.scrollHeight + "px";
                icon.textContent = '▲';
                toggle.classList.add('expanded');
                content.classList.add('expanded');

                // Special handling for the historical data section
                if (targetId === 'previous-hourly-forecast-content') {
                    // Check if data is already loaded and visible
                    if (historicalDataDisplay.style.display === 'none' || historicalDataDisplay.innerHTML === '') {
                        // If not loaded, ensure password prompt is visible
                        passwordPromptContainer.style.display = 'flex';
                        historicalDataDisplay.style.display = 'none';
                        passwordInput.value = ''; // Clear password field
                        passwordErrorMessage.textContent = ''; // Clear error message
                    } else {
                        // If data is already loaded, hide password prompt
                        passwordPromptContainer.style.display = 'none';
                        historicalDataDisplay.style.display = 'grid'; // Assuming it's a grid layout
                    }
                }
            }
        }

        function expandSection(id) {
            const content = document.getElementById(id);
            const toggle = content.previousElementSibling;
            const icon = toggle.querySelector('.toggle-icon');

            content.style.maxHeight = content.scrollHeight + "px";
            icon.textContent = '▲';
            toggle.classList.add('expanded');
            content.classList.add('expanded');
        }

        function collapseSection(id) {
            const content = document.getElementById(id);
            const toggle = content.previousElementSibling;
            const icon = toggle.querySelector('.toggle-icon');

            content.style.maxHeight = "0px";
            icon.textContent = '▼';
            toggle.classList.remove('expanded');
            content.classList.remove('expanded');
        }

        // --- Gestion du mot de passe pour les données historiques ---
        btnUnlockHistory.addEventListener('click', async () => {
            const password = passwordInput.value;
            const correctPassword = "admin"; // Le mot de passe requis

            if (password === correctPassword) {
                passwordErrorMessage.textContent = '';
                passwordPromptContainer.style.display = 'none'; // Hide password prompt
                historicalDataDisplay.style.display = 'grid'; // Show historical data container
                previousHourlyLoadingMessage.textContent = 'Chargement des données historiques...'; // Show loading message

                try {
                    const historicalHourlyData = await getHistoricalHourlyData(currentLat, currentLon);
                    if (historicalHourlyData.length > 0) {
                        displayHourlyForecast(historicalHourlyData, historicalDataDisplay);
                        // AJOUTE CETTE LIGNE CI-DESSOUS
                        expandSection('previous-hourly-forecast-content'); // Ajuste la hauteur après le chargement
                    } else {
                        historicalDataDisplay.innerHTML = '<p class="error-message">Données historiques des 24h précédentes non disponibles pour cette localisation ou période.</p>';
                    }
                } catch (error) {
                    console.error('Erreur lors du chargement des données historiques :', error);
                    historicalDataDisplay.innerHTML = '<p class="error-message">Impossible de charger les données historiques. Problème de connexion ou données non disponibles.</p>';
                }
            } else {
                passwordErrorMessage.textContent = 'Mot de passe incorrect. Essaie encore !';
            }
        });

        // --- Gestion du clic sur l'icône d'alerte ---
        document.addEventListener('click', (event) => {
            const alertIcon = event.target.closest('.alert-icon');
            if (alertIcon) {
                event.preventDefault(); // Empêche le comportement par défaut du lien
                const alertsContentId = 'weather-alerts-content';
                const alertsSection = document.getElementById('weather-alerts-section');

                // 1. Déplier la section des alertes si elle est repliée
                if (document.getElementById(alertsContentId).style.maxHeight === "0px" || !document.getElementById(alertsContentId).style.maxHeight) {
                    expandSection(alertsContentId);
                }

                // 2. Faire défiler jusqu'à la section des alertes après un court délai
                // (pour laisser le temps à la transition de dépliage de se terminer)
                setTimeout(() => {
                    alertsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }, 500); // Délai de 500ms, ajustable si la transition est plus longue
            }
        });


        // Initialisation au chargement du DOM
        document.addEventListener('DOMContentLoaded', () => {
            updateWeatherForLocation(DEFAULT_LAT, DEFAULT_LON, DEFAULT_LOCATION_NAME);
            
            // Initialiser les états des accordéons par défaut (pliés/dépliés)
            // Ceux avec 'expanded' dans le HTML sont déjà visuellement dépliés,
            // mais nous devons définir leur maxHeight via JS pour la transition.
            // Les autres sont par défaut repliés par CSS.
            setTimeout(() => { // Petite temporisation pour s'assurer que le contenu est rendu
                document.querySelectorAll('.collapsible-content.expanded').forEach(content => {
                    content.style.maxHeight = content.scrollHeight + "px";
                });
            }, 100); // Ajuste cette valeur si nécessaire

            // Masquer le contenu historique au démarrage et afficher le prompt
            historicalDataDisplay.style.display = 'none';
            passwordPromptContainer.style.display = 'flex';
        });
    </script>
</body>
</html>
